        - # AbstractInterpretation -- this is an instance of a Julia AbstractInterpreter. We use it
        - # in conjunction with the contexts above to decide what should be inlined and what should
        - # not be inlined. Similar strategies are employed by Enzyme and Diffractor.
        - 
        - # The most important bit of this code is `inlining_policy` -- the rest is copy + pasted
        - # boiler plate, largely taken from https://github.com/JuliaLang/julia/blob/2fe4190b3d26b4eee52b2b1b1054ddd6e38a941e/test/compiler/newinterp.jl#L11
        - #
        - # Credit: much of the code in here is copied over from the main Julia repo, and from
        - # Enzyme.jl, which has a very similar set of concerns to Mooncake in terms of avoiding
        - # inlining primitive functions.
        - #
        - 
        - struct ClosureCacheKey
        3     world_age::UInt
        -     key::Any
        - end
        - 
        - struct MooncakeCache
        1     dict::IdDict{Core.MethodInstance,Core.CodeInstance}
        - end
        - 
        1 MooncakeCache() = MooncakeCache(IdDict{Core.MethodInstance,Core.CodeInstance}())
        - 
        - # The method table used by `Mooncake.@mooncake_overlay`.
        - Base.Experimental.@MethodTable mooncake_method_table
        - 
        - struct MooncakeInterpreter{C} <: CC.AbstractInterpreter
        -     meta # additional information
        -     world::UInt
        -     inf_params::CC.InferenceParams
        -     opt_params::CC.OptimizationParams
        -     inf_cache::Vector{CC.InferenceResult}
        -     code_cache::MooncakeCache
        -     oc_cache::Dict{ClosureCacheKey,Any}
        2     function MooncakeInterpreter(
        -         ::Type{C};
        -         meta=nothing,
        -         world::UInt=Base.get_world_counter(),
        -         inf_params::CC.InferenceParams=CC.InferenceParams(),
        -         opt_params::CC.OptimizationParams=CC.OptimizationParams(),
        -         inf_cache::Vector{CC.InferenceResult}=CC.InferenceResult[],
        -         code_cache::MooncakeCache=MooncakeCache(),
        -         oc_cache::Dict{ClosureCacheKey,Any}=Dict{ClosureCacheKey,Any}(),
        -     ) where {C}
        1         ip = new{C}(meta, world, inf_params, opt_params, inf_cache, code_cache, oc_cache)
        5         tts = Any[
        -             Tuple{typeof(sum),Tuple{Int}},
        -             Tuple{typeof(sum),Tuple{Int,Int}},
        -             Tuple{typeof(sum),Tuple{Int,Int,Int}},
        -             Tuple{typeof(sum),Tuple{Int,Int,Int,Int}},
        -             Tuple{typeof(sum),Tuple{Int,Int,Int,Int,Int}},
        -         ]
        1         for tt in tts
        5             for m in CC._methods_by_ftype(tt, 10, ip.world)::Vector
        5                 m = m::CC.MethodMatch
        5                 typ = Any[m.spec_types.parameters...]
        5                 for i in 1:length(typ)
       10                     typ[i] = CC.unwraptv(typ[i])
       15                 end
        5                 CC.typeinf_type(ip, m.method, Tuple{typ...}, m.sparams)
        5             end
        5         end
        1         return ip
        -     end
        - end
        - 
        - # Don't print out the IRCode object, because this tends to pollute the REPL. Just make it
        - # clear that this is a MistyClosure, which contains an OpaqueClosure.
        - function Base.show(io::IO, mime::MIME"text/plain", mc::MooncakeInterpreter)
        -     return _show_interp(io, mime, mc)
        - end
        2 Base.show(io::IO, mc::MooncakeInterpreter) = _show_interp(io, MIME"text/plain"(), mc)
        - 
        2 function _show_interp(io::IO, ::MIME"text/plain", ::MooncakeInterpreter)
        2     return print(io, "MooncakeInterpreter()")
        - end
        - 
        1 MooncakeInterpreter() = MooncakeInterpreter(DefaultCtx)
        - 
       31 context_type(::MooncakeInterpreter{C}) where {C} = C
        - 
    36081 CC.InferenceParams(interp::MooncakeInterpreter) = interp.inf_params
    19836 CC.OptimizationParams(interp::MooncakeInterpreter) = interp.opt_params
     3538 CC.get_inference_cache(interp::MooncakeInterpreter) = interp.inf_cache
     6403 function CC.code_cache(interp::MooncakeInterpreter)
    13406     return CC.WorldView(interp.code_cache, CC.WorldRange(interp.world))
        - end
     6403 function CC.get(wvc::CC.WorldView{MooncakeCache}, mi::Core.MethodInstance, default)
    22083     return get(wvc.cache.dict, mi, default)
        - end
        - function CC.getindex(wvc::CC.WorldView{MooncakeCache}, mi::Core.MethodInstance)
        -     return getindex(wvc.cache.dict, mi)
        - end
        0 function CC.haskey(wvc::CC.WorldView{MooncakeCache}, mi::Core.MethodInstance)
      926     return haskey(wvc.cache.dict, mi)
        - end
        0 function CC.setindex!(
        -     wvc::CC.WorldView{MooncakeCache}, ci::Core.CodeInstance, mi::Core.MethodInstance
        - )
      926     return setindex!(wvc.cache.dict, ci, mi)
        - end
     6399 function CC.method_table(interp::MooncakeInterpreter)
     6399     return CC.OverlayMethodTable(interp.world, mooncake_method_table)
        - end
        - 
        - @static if VERSION < v"1.11.0"
        -     CC.get_world_counter(interp::MooncakeInterpreter) = interp.world
        -     get_inference_world(interp::CC.AbstractInterpreter) = CC.get_world_counter(interp)
        - else
     3358     CC.get_inference_world(interp::MooncakeInterpreter) = interp.world
        -     CC.cache_owner(::MooncakeInterpreter) = nothing
        4     get_inference_world(interp::CC.AbstractInterpreter) = CC.get_inference_world(interp)
        - end
        - 
        - struct NoInlineCallInfo <: CC.CallInfo
      198     info::CC.CallInfo # wrapped call
        -     tt::Any # signature
        - end
        - 
      130 CC.nsplit_impl(info::NoInlineCallInfo) = CC.nsplit(info.info)
      129 CC.getsplit_impl(info::NoInlineCallInfo, idx::Int) = CC.getsplit(info.info, idx)
      129 CC.getresult_impl(info::NoInlineCallInfo, idx::Int) = CC.getresult(info.info, idx)
        - 
     6407 function Core.Compiler.abstract_call_gf_by_type(
        -     interp::MooncakeInterpreter{C},
        -     @nospecialize(f),
        -     arginfo::CC.ArgInfo,
        -     si::CC.StmtInfo,
        -     @nospecialize(atype),
        -     sv::CC.AbsIntState,
        -     max_methods::Int,
        - ) where {C}
        - 
        -     # invoke the default abstract call to get the default CC.CallMeta.
     6407     cm = @invoke CC.abstract_call_gf_by_type(
        -         interp::CC.AbstractInterpreter,
        -         f::Any,
        -         arginfo::CC.ArgInfo,
        -         si::CC.StmtInfo,
        -         atype::Any,
        -         sv::CC.AbsIntState,
        -         max_methods::Int,
        -     )
        - 
        -     # Check to see whether the call in question is a Mooncake primitive. If it is, set its
        -     # call info such that in the `CC.inlining_policy` it is not inlined away.
    12616     callinfo = is_primitive(C, atype) ? NoInlineCallInfo(cm.info, atype) : cm.info
        - 
        -     # Construct a CallMeta correctly depending on the version of Julia.
        0     @static if VERSION â‰¥ v"1.11-"
     6407         return CC.CallMeta(cm.rt, cm.exct, cm.effects, callinfo)
        -     else
        -         return CC.CallMeta(cm.rt, cm.effects, callinfo)
        -     end
        - end
        - 
        - @static if VERSION < v"1.11-"
        -     function CC.inlining_policy(
        -         interp::MooncakeInterpreter{C},
        -         @nospecialize(src),
        -         @nospecialize(info::CC.CallInfo),
        -         stmt_flag::UInt8,
        -         mi::Core.MethodInstance,
        -         argtypes::Vector{Any},
        -     ) where {C}
        - 
        -         # Do not inline away primitives.
        -         info isa NoInlineCallInfo && return nothing
        - 
        -         # If not a primitive, AD doesn't care about it. Use the usual inlining strategy.
        -         return @invoke CC.inlining_policy(
        -             interp::CC.AbstractInterpreter,
        -             src::Any,
        -             info::CC.CallInfo,
        -             stmt_flag::UInt8,
        -             mi::Core.MethodInstance,
        -             argtypes::Vector{Any},
        -         )
        -     end
        - 
        - else # 1.11 and up.
        0     function CC.inlining_policy(
        -         interp::MooncakeInterpreter,
        -         @nospecialize(src),
        -         @nospecialize(info::CC.CallInfo),
        -         stmt_flag::UInt32,
        -     )
        -         # Do not inline away primitives.
     5279         info isa NoInlineCallInfo && return nothing
        - 
        -         # If not a primitive, AD doesn't care about it. Use the usual inlining strategy.
     5674         return @invoke CC.inlining_policy(
        -             interp::CC.AbstractInterpreter, src::Any, info::CC.CallInfo, stmt_flag::UInt32
        -         )
        -     end
        - end
        - 
        - """
        -     const GLOBAL_INTERPRETER
        - 
        - Globally cached interpreter. Should only be accessed via `get_interpreter`.
        - """
        - const GLOBAL_INTERPRETER = Ref(MooncakeInterpreter())
        - 
        - """
        -     get_interpreter()
        - 
        - Returns a `MooncakeInterpreter` appropriate for the current world age. Will use a cached
        - interpreter if one already exists for the current world age, otherwise creates a new one.
        - 
        - This should be prefered over constructing a `MooncakeInterpreter` directly.
        - """
        6 function get_interpreter()
        6     if GLOBAL_INTERPRETER[].world != Base.get_world_counter()
        1         GLOBAL_INTERPRETER[] = MooncakeInterpreter()
        -     end
        6     return GLOBAL_INTERPRETER[]
        - end
