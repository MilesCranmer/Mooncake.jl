        - """
        -     module BasicBlockCode
        - 
        - See the docstring for the `BBCode` `struct` for info on this file.
        - """
        - module BasicBlockCode
        - 
        - using Graphs
        - 
        - using Core.Compiler:
        -     ReturnNode,
        -     PhiNode,
        -     GotoIfNot,
        -     GotoNode,
        -     NewInstruction,
        -     IRCode,
        -     SSAValue,
        -     PiNode,
        -     Argument
        - const CC = Core.Compiler
        - 
        - export ID,
        -     seed_id!,
        -     IDPhiNode,
        -     IDGotoNode,
        -     IDGotoIfNot,
        -     Switch,
        -     BBlock,
        -     phi_nodes,
        -     terminator,
        -     insert_before_terminator!,
        -     collect_stmts,
        -     compute_all_predecessors,
        -     BBCode,
        -     remove_unreachable_blocks!,
        -     characterise_used_ids,
        -     characterise_unique_predecessor_blocks,
        -     sort_blocks!,
        -     InstVector,
        -     IDInstPair,
        -     __line_numbers_to_block_numbers!,
        -     is_reachable_return_node,
        -     new_inst
        - 
        - const _id_count::Dict{Int,Int32} = Dict{Int,Int32}()
        - 
        - """
        -     new_inst(stmt, type=Any, flag=CC.IR_FLAG_REFINED)::NewInstruction
        - 
        - Create a `NewInstruction` with fields:
        - - `stmt` = `stmt`
        - - `type` = `type`
        - - `info` = `CC.NoCallInfo()`
        - - `line` = `Int32(1)`
        - - `flag` = `flag`
        - """
     3813 function new_inst(@nospecialize(stmt), @nospecialize(type)=Any, flag=CC.IR_FLAG_REFINED)
     3813     return NewInstruction(stmt, type, CC.NoCallInfo(), Int32(1), flag)
        - end
        - 
        - """
        -     const InstVector = Vector{NewInstruction}
        - 
        - Note: the `CC.NewInstruction` type is used to represent instructions because it has the
        - correct fields. While it is only used to represent new instrucdtions in `Core.Compiler`, it
        - is used to represent all instructions in `BBCode`.
        - """
        - const InstVector = Vector{NewInstruction}
        - 
        - """
        -     ID()
        - 
        - An `ID` (read: unique name) is just a wrapper around an `Int32`. Uniqueness is ensured via a
        - global counter, which is incremented each time that an `ID` is created.
        - 
        - This counter can be reset using `seed_id!` if you need to ensure deterministic `ID`s are
        - produced, in the same way that seed for random number generators can be set.
        - """
        - struct ID
        -     id::Int32
     1617     function ID()
     1617         current_thread_id = Threads.threadid()
     3234         id_count = get(_id_count, current_thread_id, Int32(0))
     1617         _id_count[current_thread_id] = id_count + Int32(1)
     1617         return new(id_count)
        -     end
        - end
        - 
        - Base.copy(id::ID) = id
        - 
        - """
        -     seed_id!()
        - 
        - Set the global counter used to ensure ID uniqueness to 0. This is useful when you want to
        - ensure determinism between two runs of the same function which makes use of `ID`s.
        - 
        - This is akin to setting the random seed associated to a random number generator globally.
        - """
        3 function seed_id!()
        3     return global _id_count[Threads.threadid()] = 0
        - end
        - 
        - """
        -     IDPhiNode(edges::Vector{ID}, values::Vector{Any})
        - 
        - Like a `PhiNode`, but `edges` are `ID`s rather than `Int32`s.
        - """
        - struct IDPhiNode
        6     edges::Vector{ID}
        -     values::Vector{Any}
        - end
        - 
        - Base.:(==)(x::IDPhiNode, y::IDPhiNode) = x.edges == y.edges && x.values == y.values
        - 
        - Base.copy(node::IDPhiNode) = IDPhiNode(copy(node.edges), copy(node.values))
        - 
        - """
        -     IDGotoNode(label::ID)
        - 
        - Like a `GotoNode`, but `label` is an `ID` rather than an `Int64`.
        - """
        - struct IDGotoNode
       58     label::ID
        - end
        - 
        - Base.copy(node::IDGotoNode) = IDGotoNode(copy(node.label))
        - 
        - """
        -     IDGotoIfNot(cond::Any, dest::ID)
        - 
        - Like a `GotoIfNot`, but `dest` is an `ID` rather than an `Int64`.
        - """
        - struct IDGotoIfNot
       24     cond::Any
        -     dest::ID
        - end
        - 
        - Base.copy(node::IDGotoIfNot) = IDGotoIfNot(copy(node.cond), copy(node.dest))
        - 
        - """
        -     Switch(conds::Vector{Any}, dests::Vector{ID}, fallthrough_dest::ID)
        - 
        - A switch-statement node. These can be inserted in the `BBCode` representation of Julia IR.
        - `Switch` has the following semantics:
        - ```julia
        - goto dests[1] if not conds[1]
        - goto dests[2] if not conds[2]
        - ...
        - goto dests[N] if not conds[N]
        - goto fallthrough_dest
        - ```
        - where the value associated to each element of `conds` is a `Bool`, and `dests` indicate
        - which block to jump to. If none of the conditions are met, then we go to whichever block is
        - specified by `fallthrough_dest`.
        - 
        - `Switch` statements are lowered into the above sequence of `GotoIfNot`s and `GotoNode`s
        - when converting `BBCode` back into `IRCode`, because `Switch` statements are not valid
        - nodes in regular Julia IR.
        - """
        - struct Switch
        -     conds::Vector{Any}
        -     dests::Vector{ID}
        -     fallthrough_dest::ID
       36     function Switch(conds::Vector{Any}, dests::Vector{ID}, fallthrough_dest::ID)
       36         @assert length(conds) == length(dests)
       36         return new(conds, dests, fallthrough_dest)
        -     end
        - end
        - 
        - """
        -     Terminator = Union{Switch, IDGotoIfNot, IDGotoNode, ReturnNode}
        - 
        - A Union of the possible types of a terminator node.
        - """
        - const Terminator = Union{Switch,IDGotoIfNot,IDGotoNode,ReturnNode}
        - 
        - """
        -     BBlock(id::ID, stmt_ids::Vector{ID}, stmts::InstVector)
        - 
        - A basic block data structure (not called `BasicBlock` to avoid accidental confusion with
        - `CC.BasicBlock`). Forms a single basic block.
        - 
        - Each `BBlock` has an `ID` (a unique name). This makes it possible to refer to blocks in a
        - way that does not change when additional `BBlocks` are inserted into a `BBCode`.
        - This differs from the positional block numbering found in `IRCode`, in which the number
        - associated to a basic block changes when new blocks are inserted.
        - 
        - The `n`th line of code in a `BBlock` is associated to `ID` `stmt_ids[n]`, and the `n`th
        - instruction from `stmts`.
        - 
        - Note that `PhiNode`s, `GotoIfNot`s, and `GotoNode`s should not appear in a `BBlock` --
        - instead an `IDPhiNode`, `IDGotoIfNot`, or `IDGotoNode` should be used.
        - """
        - mutable struct BBlock
        -     id::ID
        -     inst_ids::Vector{ID}
        -     insts::InstVector
      201     function BBlock(id::ID, inst_ids::Vector{ID}, insts::InstVector)
      201         @assert length(inst_ids) == length(insts)
      201         return new(id, inst_ids, insts)
        -     end
        - end
        - 
        - """
        -     const IDInstPair = Tuple{ID, NewInstruction}
        - """
        - const IDInstPair = Tuple{ID,NewInstruction}
        - 
        - """
        -     BBlock(id::ID, inst_pairs::Vector{IDInstPair})
        - 
        - Convenience constructor -- splits `inst_pairs` into a `Vector{ID}` and `InstVector` in order
        - to build a `BBlock`.
        - """
       89 function BBlock(id::ID, inst_pairs::Vector{IDInstPair})
       89     return BBlock(id, first.(inst_pairs), last.(inst_pairs))
        - end
        - 
      248 Base.length(bb::BBlock) = length(bb.inst_ids)
        - 
        - Base.copy(bb::BBlock) = BBlock(bb.id, copy(bb.inst_ids), copy(bb.insts))
        - 
        - """
        -     phi_nodes(bb::BBlock)::Tuple{Vector{ID}, Vector{IDPhiNode}}
        - 
        - Returns all of the `IDPhiNode`s at the start of `bb`, along with their `ID`s. If there are
        - no `IDPhiNode`s at the start of `bb`, then both vectors will be empty.
        - """
       33 function phi_nodes(bb::BBlock)
      673     n_phi_nodes = findlast(x -> x.stmt isa IDPhiNode, bb.insts)
       33     if n_phi_nodes === nothing
       30         n_phi_nodes = 0
        -     end
       33     return bb.inst_ids[1:n_phi_nodes], bb.insts[1:n_phi_nodes]
        - end
        - 
        - """
        -     Base.insert!(bb::BBlock, n::Int, id::ID, stmt::CC.NewInstruction)::Nothing
        - 
        - Inserts `stmt` and `id` into `bb` immediately before the `n`th instruction.
        - """
       84 function Base.insert!(bb::BBlock, n::Int, id::ID, inst::NewInstruction)::Nothing
       84     insert!(bb.inst_ids, n, id)
       84     insert!(bb.insts, n, inst)
       84     return nothing
        - end
        - 
        - """
        -     terminator(bb::BBlock)
        - 
        - Returns the terminator associated to `bb`. If the last instruction in `bb` isa
        - `Terminator` then that is returned, otherwise `nothing` is returned.
        - """
     1049 terminator(bb::BBlock) = isa(bb.insts[end].stmt, Terminator) ? bb.insts[end].stmt : nothing
        - 
        - """
        -     insert_before_terminator!(bb::BBlock, id::ID, inst::NewInstruction)::Nothing
        - 
        - If the final instruction in `bb` is a `Terminator`, insert `inst` immediately before it.
        - Otherwise, insert `inst` at the end of the block.
        - """
       84 function insert_before_terminator!(bb::BBlock, id::ID, inst::NewInstruction)::Nothing
       84     insert!(bb, length(bb.insts) + (terminator(bb) === nothing ? 1 : 0), id, inst)
       84     return nothing
        - end
        - 
        - """
        -     collect_stmts(bb::BBlock)::Vector{IDInstPair}
        - 
        - Returns a `Vector` containing the `ID`s and instructions associated to each line in `bb`.
        - These should be assumed to be ordered.
        - """
       37 collect_stmts(bb::BBlock)::Vector{IDInstPair} = collect(zip(bb.inst_ids, bb.insts))
        - 
        - """
        -     BBCode(
        -         blocks::Vector{BBlock}
        -         argtypes::Vector{Any}
        -         sptypes::Vector{CC.VarState}
        -         linetable::Vector{Core.LineInfoNode}
        -         meta::Vector{Expr}
        -     )
        - 
        - A `BBCode` is a data structure which is similar to `IRCode`, but adds additional structure.
        - 
        - In particular, a `BBCode` comprises a sequence of basic blocks (`BBlock`s), each of which
        - comprise a sequence of statements. Moreover, each `BBlock` has its own unique `ID`, as does
        - each statment.
        - 
        - The consequence of this is that new basic blocks can be inserted into a `BBCode`. This is
        - distinct from `IRCode`, in which to create a new basic block, one must insert additional
        - statments which you know will create a new basic block -- this is generally quite an
        - unreliable process, while inserting a new `BBlock` into `BBCode` is entirely predictable.
        - Furthermore, inserting a new `BBlock` does not change the `ID` associated to the other
        - blocks, meaning that you can safely assume that references from existing basic block
        - terminators / phi nodes to other blocks will not be modified by inserting a new basic block.
        - 
        - Additionally, since each statment in each basic block has its own unique `ID`, new
        - statments can be inserted without changing references between other blocks. `IRCode` also
        - has some support for this via its `new_nodes` field, but eventually all statements will be
        - renamed upon `compact!`ing the `IRCode`, meaning that the name of any given statement will
        - eventually change.
        - 
        - Finally, note that the basic blocks in a `BBCode` support the custom `Switch` statement.
        - This statement is not valid in `IRCode`, and is therefore lowered into a collection of
        - `GotoIfNot`s and `GotoNode`s when a `BBCode` is converted back into an `IRCode`.
        - """
        - struct BBCode
       30     blocks::Vector{BBlock}
        -     argtypes::Vector{Any}
        -     sptypes::Vector{CC.VarState}
        -     linetable::Vector{Core.LineInfoNode}
        -     meta::Vector{Expr}
        - end
        - 
        - """
        -     BBCode(ir::Union{IRCode, BBCode}, new_blocks::Vector{Block})
        - 
        - Make a new `BBCode` whose `blocks` is given by `new_blocks`, and fresh copies are made of
        - all other fields from `ir`.
        - """
       24 function BBCode(ir::Union{IRCode,BBCode}, new_blocks::Vector{BBlock})
       24     return BBCode(
        -         new_blocks,
        -         CC.copy(ir.argtypes),
        -         CC.copy(ir.sptypes),
        -         CC.copy(ir.linetable),
        -         CC.copy(ir.meta),
        -     )
        - end
        - 
        - # Makes use of the above outer constructor for `BBCode`.
        - Base.copy(ir::BBCode) = BBCode(ir, copy(ir.blocks))
        - 
        - """
        -     compute_all_successors(ir::BBCode)::Dict{ID, Vector{ID}}
        - 
        - Compute a map from the `ID` of each `BBlock` in `ir` to its possible successors.
        - """
        - compute_all_successors(ir::BBCode)::Dict{ID,Vector{ID}} = _compute_all_successors(ir.blocks)
        - 
        - """
        -     _compute_all_successors(blks::Vector{BBlock})::Dict{ID, Vector{ID}}
        - 
        - Internal method implementing [`compute_all_successors`](@ref). This method is easier to
        - construct test cases for because it only requires the collection of `BBlocks`, not all of
        - the other stuff that goes into a `BBCode`.
        - """
       39 @noinline function _compute_all_successors(blks::Vector{BBlock})::Dict{ID,Vector{ID}}
       39     succs = map(enumerate(blks)) do (n, blk)
      608         is_final_block = n == length(blks)
      608         t = terminator(blk)
      608         if t === nothing
      152             return is_final_block ? ID[] : ID[blks[n + 1].id]
      456         elseif t isa IDGotoNode
      240             return [t.label]
      216         elseif t isa IDGotoIfNot
       69             return is_final_block ? ID[t.dest] : ID[t.dest, blks[n + 1].id]
      147         elseif t isa ReturnNode
       75             return ID[]
       72         elseif t isa Switch
       72             return vcat(t.dests, t.fallthrough_dest)
        -         else
        0             error("Unhandled terminator $t")
        -         end
        -     end
       39     return Dict{ID,Vector{ID}}((b.id, succ) for (b, succ) in zip(blks, succs))
        - end
        - 
        - """
        -     compute_all_predecessors(ir::BBCode)::Dict{ID, Vector{ID}}
        - 
        - Compute a map from the `ID` of each `BBlock` in `ir` to its possible predecessors.
        - """
        3 function compute_all_predecessors(ir::BBCode)::Dict{ID,Vector{ID}}
        3     return _compute_all_predecessors(ir.blocks)
        - end
        - 
        - """
        -     _compute_all_predecessors(blks::Vector{BBlock})::Dict{ID, Vector{ID}}
        - 
        - Internal method implementing [`compute_all_predecessors`](@ref). This method is easier to
        - construct test cases for because it only requires the collection of `BBlocks`, not all of
        - the other stuff that goes into a `BBCode`.
        - """
       15 function _compute_all_predecessors(blks::Vector{BBlock})::Dict{ID,Vector{ID}}
       15     successor_map = _compute_all_successors(blks)
        - 
        -     # Initialise predecessor map to be empty.
       30     ks = collect(keys(successor_map))
      250     predecessor_map = Dict{ID,Vector{ID}}(zip(ks, map(_ -> ID[], ks)))
        - 
        -     # Find all predecessors by iterating through the successor map.
       30     for (k, succs) in successor_map
      235         for succ in succs
      235             push!(predecessor_map[succ], k)
      235         end
      455     end
        - 
       15     return predecessor_map
        - end
        - 
        - """
        -     collect_stmts(ir::BBCode)::Vector{IDInstPair}
        - 
        - Produce a `Vector` containing all of the statements in `ir`. These are returned in
        - order, so it is safe to assume that element `n` refers to the `nth` element of the `IRCode`
        - associated to `ir`. 
        - """
        3 collect_stmts(ir::BBCode)::Vector{IDInstPair} = reduce(vcat, map(collect_stmts, ir.blocks))
        - 
        - """
        -     id_to_line_map(ir::BBCode)
        - 
        - Produces a `Dict` mapping from each `ID` associated with a line in `ir` to its line number.
        - This is isomorphic to mapping to its `SSAValue` in `IRCode`. Terminators do not have `ID`s
        - associated to them, so not every line in the original `IRCode` is mapped to.
        - """
        - function id_to_line_map(ir::BBCode)
        -     lines = collect_stmts(ir)
        -     lines_and_line_numbers = collect(zip(lines, eachindex(lines)))
        -     ids_and_line_numbers = map(x -> (x[1][1], x[2]), lines_and_line_numbers)
        -     return Dict(ids_and_line_numbers)
        - end
        - 
      130 concatenate_ids(bb_code::BBCode) = reduce(vcat, map(b -> b.inst_ids, bb_code.blocks))
      130 concatenate_stmts(bb_code::BBCode) = reduce(vcat, map(b -> b.insts, bb_code.blocks))
        - 
        - """
        -     control_flow_graph(bb_code::BBCode)::Core.Compiler.CFG
        - 
        - Computes the `Core.Compiler.CFG` object associated to this `bb_code`.
        - """
        6 control_flow_graph(bb_code::BBCode)::Core.Compiler.CFG = _control_flow_graph(bb_code.blocks)
        - 
        - """
        -     _control_flow_graph(blks::Vector{BBlock})::Core.Compiler.CFG
        - 
        - Internal function, used to implement [`control_flow_graph`](@ref). Easier to write test
        - cases for because there is no need to construct an ensure BBCode object, just the `BBlock`s.
        - """
        6 function _control_flow_graph(blks::Vector{BBlock})::Core.Compiler.CFG
        - 
        -     # Get IDs of predecessors and successors.
        6     preds_ids = _compute_all_predecessors(blks)
        6     succs_ids = _compute_all_successors(blks)
        - 
        -     # Construct map from block ID to block number.
      130     block_ids = map(b -> b.id, blks)
      124     id_to_num = Dict{ID,Int}(zip(block_ids, collect(eachindex(block_ids))))
        - 
        -     # Convert predecessor and successor IDs to numbers.
      254     preds = map(id -> sort(map(p -> id_to_num[p], preds_ids[id])), block_ids)
      254     succs = map(id -> sort(map(s -> id_to_num[s], succs_ids[id])), block_ids)
        - 
       12     index = vcat(0, cumsum(map(length, blks))) .+ 1
        6     basic_blocks = map(eachindex(blks)) do n
      124         stmt_range = Core.Compiler.StmtRange(index[n], index[n + 1] - 1)
      124         return Core.Compiler.BasicBlock(stmt_range, preds[n], succs[n])
        -     end
        6     return Core.Compiler.CFG(basic_blocks, index[2:(end - 1)])
        - end
        - 
        - """
        -     _instructions_to_blocks(insts::InstVector, cfg::CC.CFG)::InstVector
        - 
        - Pulls out the instructions from `insts`, and calls `__line_numbers_to_block_numbers!`.
        - """
        6 function _lines_to_blocks(insts::InstVector, cfg::CC.CFG)::InstVector
        6     stmts = __line_numbers_to_block_numbers!(Any[x.stmt for x in insts], cfg)
     3630     return map((inst, stmt) -> NewInstruction(inst; stmt), insts, stmts)
        - end
        - 
        - """
        -     __line_numbers_to_block_numbers!(insts::Vector{Any}, cfg::CC.CFG)
        - 
        - Converts any edges in `GotoNode`s, `GotoIfNot`s, `PhiNode`s, and `:enter` expressions which
        - refer to line numbers into references to block numbers. The `cfg` provides the information
        - required to perform this conversion.
        - 
        - For context, `CodeInfo` objects have references to line numbers, while `IRCode` uses
        - block numbers.
        - 
        - This code is copied over directly from the body of `Core.Compiler.inflate_ir!`.
        - """
        6 function __line_numbers_to_block_numbers!(insts::Vector{Any}, cfg::CC.CFG)
        6     for i in eachindex(insts)
     1812         stmt = insts[i]
     1812         if isa(stmt, GotoNode)
       58             insts[i] = GotoNode(CC.block_for_inst(cfg, stmt.label))
     1754         elseif isa(stmt, GotoIfNot)
       10             insts[i] = GotoIfNot(stmt.cond, CC.block_for_inst(cfg, stmt.dest))
     1744         elseif isa(stmt, PhiNode)
        3             insts[i] = PhiNode(
        -                 Int32[CC.block_for_inst(cfg, Int(edge)) for edge in stmt.edges], stmt.values
        -             )
     1741         elseif Meta.isexpr(stmt, :enter)
        0             stmt.args[1] = CC.block_for_inst(cfg, stmt.args[1]::Int)
        0             insts[i] = stmt
        -         end
     3618     end
        6     return insts
        - end
        - 
        - #
        - # Converting from IRCode to BBCode
        - #
        - 
        - """
        -     BBCode(ir::IRCode)
        - 
        - Convert an `ir` into a `BBCode`. Creates a completely independent data structure, so
        - mutating the `BBCode` returned will not mutate `ir`.
        - 
        - All `PhiNode`s, `GotoIfNot`s, and `GotoNode`s will be replaced with the `IDPhiNode`s,
        - `IDGotoIfNot`s, and `IDGotoNode`s respectively.
        - 
        - See `IRCode` for conversion back to `IRCode`.
        - 
        - Note that `IRCode(BBCode(ir))` should be equal to the identity function.
        - """
        3 function BBCode(ir::IRCode)
        - 
        -     # Produce a new set of statements with `IDs` rather than `SSAValues` and block numbers.
        3     insts = new_inst_vec(ir.stmts)
        3     ssa_ids, stmts = _ssas_to_ids(insts)
        3     block_ids, stmts = _block_nums_to_ids(stmts, ir.cfg)
        - 
        -     # Chop up the new statements into `BBlocks`, according to the `CFG` in `ir`.
        3     blocks = map(zip(ir.cfg.blocks, block_ids)) do (bb, id)
       37         return BBlock(id, ssa_ids[bb.stmts], stmts[bb.stmts])
        -     end
        3     return BBCode(ir, blocks)
        - end
        - 
        - """
        -     new_inst_vec(x::CC.InstructionStream)
        - 
        - Convert an `Compiler.InstructionStream` into a list of `Compiler.NewInstruction`s.
        - """
        3 function new_inst_vec(x::CC.InstructionStream)
        3     stmt = @static VERSION < v"1.11.0-rc4" ? x.inst : x.stmt
      335     return map((v...,) -> NewInstruction(v...), stmt, x.type, x.info, x.line, x.flag)
        - end
        - 
        - # Maps from positional names (SSAValues for nodes, Integers for basic blocks) to IDs.
        - const SSAToIdDict = Dict{SSAValue,ID}
        - const BlockNumToIdDict = Dict{Integer,ID}
        - 
        - """
        -     _ssas_to_ids(insts::InstVector)::Tuple{Vector{ID}, InstVector}
        - 
        - Assigns an ID to each line in `stmts`, and replaces each instance of an `SSAValue` in each
        - line with the corresponding `ID`. For example, a call statement of the form
        - `Expr(:call, :f, %4)` is be replaced with `Expr(:call, :f, id_assigned_to_%4)`.
        - """
        3 function _ssas_to_ids(insts::InstVector)::Tuple{Vector{ID},InstVector}
      335     ids = map(_ -> ID(), insts)
        3     val_id_map = SSAToIdDict(zip(SSAValue.(eachindex(insts)), ids))
        3     return ids, map(Base.Fix1(_ssa_to_ids, val_id_map), insts)
        - end
        - 
        - """
        -     _ssa_to_ids(d::SSAToIdDict, inst::NewInstruction)
        - 
        - Produce a new instance of `inst` in which all instances of `SSAValue`s are replaced with
        - the `ID`s prescribed by `d`, all basic block numbers are replaced with the `ID`s
        - prescribed by `d`, and `GotoIfNot`, `GotoNode`, and `PhiNode` instances are replaced with
        - the corresponding `ID` versions.
        - """
      332 function _ssa_to_ids(d::SSAToIdDict, inst::NewInstruction)
      332     return NewInstruction(inst; stmt=_ssa_to_ids(d, inst.stmt))
        - end
        7 function _ssa_to_ids(d::SSAToIdDict, x::ReturnNode)
        7     return isdefined(x, :val) ? ReturnNode(get(d, x.val, x.val)) : x
        - end
      471 _ssa_to_ids(d::SSAToIdDict, x::Expr) = Expr(x.head, map(a -> get(d, a, a), x.args)...)
        - _ssa_to_ids(d::SSAToIdDict, x::PiNode) = PiNode(get(d, x.val, x.val), get(d, x.typ, x.typ))
        - _ssa_to_ids(d::SSAToIdDict, x::QuoteNode) = x
        5 _ssa_to_ids(d::SSAToIdDict, x) = x
        3 function _ssa_to_ids(d::SSAToIdDict, x::PhiNode)
        6     new_values = Vector{Any}(undef, length(x.values))
        3     for n in eachindex(x.values)
        6         if isassigned(x.values, n)
        6             new_values[n] = get(d, x.values[n], x.values[n])
        -         end
        9     end
        3     return PhiNode(x.edges, new_values)
        - end
       16 _ssa_to_ids(d::SSAToIdDict, x::GotoNode) = x
        7 _ssa_to_ids(d::SSAToIdDict, x::GotoIfNot) = GotoIfNot(get(d, x.cond, x.cond), x.dest)
        - 
        - """
        -     _block_nums_to_ids(insts::InstVector, cfg::CC.CFG)::Tuple{Vector{ID}, InstVector}
        - 
        - Assign to each basic block in `cfg` an `ID`. Replace all integers referencing block numbers
        - in `insts` with the corresponding `ID`. Return the `ID`s and the updated instructions.
        - """
        3 function _block_nums_to_ids(insts::InstVector, cfg::CC.CFG)::Tuple{Vector{ID},InstVector}
       40     ids = map(_ -> ID(), cfg.blocks)
        3     block_num_id_map = BlockNumToIdDict(zip(eachindex(cfg.blocks), ids))
        3     return ids, map(Base.Fix1(_block_num_to_ids, block_num_id_map), insts)
        - end
        - 
      332 function _block_num_to_ids(d::BlockNumToIdDict, x::NewInstruction)
      332     return NewInstruction(x; stmt=_block_num_to_ids(d, x.stmt))
        - end
        3 function _block_num_to_ids(d::BlockNumToIdDict, x::PhiNode)
        3     return IDPhiNode(ID[d[e] for e in x.edges], x.values)
        - end
       16 _block_num_to_ids(d::BlockNumToIdDict, x::GotoNode) = IDGotoNode(d[x.label])
        7 _block_num_to_ids(d::BlockNumToIdDict, x::GotoIfNot) = IDGotoIfNot(x.cond, d[x.dest])
      306 _block_num_to_ids(d::BlockNumToIdDict, x) = x
        - 
        - #
        - # Converting from BBCode to IRCode
        - #
        - 
        - """
        -     IRCode(bb_code::BBCode)
        - 
        - Produce an `IRCode` instance which is equivalent to `bb_code`. The resulting `IRCode`
        - shares no memory with `bb_code`, so can be safely mutated without modifying `bb_code`.
        - 
        - All `IDPhiNode`s, `IDGotoIfNot`s, and `IDGotoNode`s are converted into `PhiNode`s,
        - `GotoIfNot`s, and `GotoNode`s respectively.
        - 
        - In the resulting `bb_code`, any `Switch` nodes are lowered into a semantically-equivalent
        - collection of `GotoIfNot` nodes.
        - """
        6 function CC.IRCode(bb_code::BBCode)
        6     bb_code = _lower_switch_statements(bb_code)
        6     bb_code = _remove_double_edges(bb_code)
        6     insts = _ids_to_line_numbers(bb_code)
        6     cfg = control_flow_graph(bb_code)
        6     insts = _lines_to_blocks(insts, cfg)
        6     return IRCode(
        -         CC.InstructionStream(
     1812             map(x -> x.stmt, insts),
     1812             map(x -> x.type, insts),
     1812             map(x -> x.info, insts),
     1812             map(x -> x.line, insts),
     1812             map(x -> x.flag, insts),
        -         ),
        -         cfg,
        -         CC.copy(bb_code.linetable),
        -         CC.copy(bb_code.argtypes),
        -         CC.copy(bb_code.meta),
        -         CC.copy(bb_code.sptypes),
        -     )
        - end
        - 
        - """
        -     _lower_switch_statements(bb_code::BBCode)
        - 
        - Converts all `Switch`s into a semantically-equivalent collection of `GotoIfNot`s. See the
        - `Switch` docstring for an explanation of what is going on here.
        - """
        6 function _lower_switch_statements(bb_code::BBCode)
        6     new_blocks = Vector{BBlock}(undef, 0)
        6     for block in bb_code.blocks
       85         t = terminator(block)
       85         if t isa Switch
        - 
        -             # Create new block without the `Switch`.
       36             bb = BBlock(block.id, block.inst_ids[1:(end - 1)], block.insts[1:(end - 1)])
       36             push!(new_blocks, bb)
        - 
        -             # Create new blocks for each `GotoIfNot` from the `Switch`.
       36             foreach(t.conds, t.dests) do cond, dest
        3                 blk = BBlock(ID(), [ID()], [new_inst(IDGotoIfNot(cond, dest), Any)])
        3                 push!(new_blocks, blk)
        -             end
        - 
        -             # Create a new block for the fallthrough dest.
       36             fallthrough_inst = new_inst(IDGotoNode(t.fallthrough_dest), Any)
       36             push!(new_blocks, BBlock(ID(), [ID()], [fallthrough_inst]))
        -         else
       49             push!(new_blocks, block)
        -         end
       85     end
        6     return BBCode(bb_code, new_blocks)
        - end
        - 
        - """
        -     _ids_to_line_numbers(bb_code::BBCode)::InstVector
        - 
        - For each statement in `bb_code`, returns a `NewInstruction` in which every `ID` is replaced
        - by either an `SSAValue`, or an `Int64` / `Int32` which refers to an `SSAValue`.
        - """
        6 function _ids_to_line_numbers(bb_code::BBCode)::InstVector
        - 
        -     # Construct map from `ID`s to `SSAValue`s.
        6     block_ids = [b.id for b in bb_code.blocks]
        6     block_lengths = map(length, bb_code.blocks)
        6     block_start_ssas = SSAValue.(vcat(1, cumsum(block_lengths)[1:(end - 1)] .+ 1))
        6     line_ids = concatenate_ids(bb_code)
        6     line_ssas = SSAValue.(eachindex(line_ids))
        6     id_to_ssa_map = Dict(zip(vcat(block_ids, line_ids), vcat(block_start_ssas, line_ssas)))
        - 
        -     # Apply map.
        6     return [_to_ssas(id_to_ssa_map, stmt) for stmt in concatenate_stmts(bb_code)]
        - end
        - 
        - """
        -     _to_ssas(d::Dict, inst::NewInstruction)
        - 
        - Like `_ssas_to_ids`, but in reverse. Converts IDs to SSAValues / (integers corresponding
        - to ssas).
        - """
     1812 _to_ssas(d::Dict, inst::NewInstruction) = NewInstruction(inst; stmt=_to_ssas(d, inst.stmt))
       10 _to_ssas(d::Dict, x::ReturnNode) = isdefined(x, :val) ? ReturnNode(get(d, x.val, x.val)) : x
     4065 _to_ssas(d::Dict, x::Expr) = Expr(x.head, map(a -> get(d, a, a), x.args)...)
        - _to_ssas(d::Dict, x::PiNode) = PiNode(get(d, x.val, x.val), get(d, x.typ, x.typ))
       33 _to_ssas(d::Dict, x::QuoteNode) = x
      569 _to_ssas(d::Dict, x) = x
        3 function _to_ssas(d::Dict, x::IDPhiNode)
        6     new_values = Vector{Any}(undef, length(x.values))
        3     for n in eachindex(x.values)
        6         if isassigned(x.values, n)
        6             new_values[n] = get(d, x.values[n], x.values[n])
        -         end
        9     end
        9     return PhiNode(map(e -> Int32(getindex(d, e).id), x.edges), new_values)
        - end
       58 _to_ssas(d::Dict, x::IDGotoNode) = GotoNode(d[x.label].id)
       10 _to_ssas(d::Dict, x::IDGotoIfNot) = GotoIfNot(get(d, x.cond, x.cond), d[x.dest].id)
        - 
        - """
        -     _remove_double_edges(ir::BBCode)::BBCode
        - 
        - If the `dest` field of an `IDGotoIfNot` node in block `n` of `ir` points towards the `n+1`th
        - block then we have two edges from block `n` to block `n+1`. This transformation replaces all
        - such `IDGotoIfNot` nodes with unconditional `IDGotoNode`s pointing towards the `n+1`th block
        - in `ir`.
        - """
        6 function _remove_double_edges(ir::BBCode)
        6     new_blks = map(enumerate(ir.blocks)) do (n, blk)
      124         t = terminator(blk)
      124         if t isa IDGotoIfNot && t.dest == ir.blocks[n + 1].id
        0             new_insts = vcat(blk.insts[1:(end - 1)], NewInstruction(t; stmt=IDGotoNode(t.dest)))
        0             return BBlock(blk.id, blk.inst_ids, new_insts)
        -         else
      124             return blk
        -         end
        -     end
        6     return BBCode(ir, new_blks)
        - end
        - 
        - """
        -     _build_graph_of_cfg(blks::Vector{BBlock})::Tuple{SimpleDiGraph, Dict{ID, Int}}
        - 
        - Builds a `SimpleDiGraph`, `g`, representing of the CFG associated to `blks`, where `blks`
        - comprises the collection of basic blocks associated to a `BBCode`.
        - This is a type from Graphs.jl, so constructing `g` makes it straightforward to analyse the
        - control flow structure of `ir` using algorithms from Graphs.jl.
        - 
        - Returns a 2-tuple, whose first element is `g`, and whose second element is a map from
        - the `ID` associated to each basic block in `ir`, to the `Int` corresponding to its node
        - index in `g`.
        - """
       12 function _build_graph_of_cfg(blks::Vector{BBlock})::Tuple{SimpleDiGraph,Dict{ID,Int}}
      175     node_ints = collect(eachindex(blks))
      187     id_to_int = Dict(zip(map(blk -> blk.id, blks), node_ints))
       12     successors = _compute_all_successors(blks)
       12     g = SimpleDiGraph(length(blks))
       12     for blk in blks, successor in successors[blk.id]
      173         add_edge!(g, id_to_int[blk.id], id_to_int[successor])
      173     end
       12     return g, id_to_int
        - end
        - 
        - """
        -     _distance_to_entry(blks::Vector{BBlock})::Vector{Int}
        - 
        - For each basic block in `blks`, compute the distance from it to the entry point (the first
        - block. The distance is `typemax(Int)` if no path from the entry point to a given node.
        - """
       12 function _distance_to_entry(blks::Vector{BBlock})::Vector{Int}
       12     g, id_to_int = _build_graph_of_cfg(blks)
       12     return dijkstra_shortest_paths(g, id_to_int[blks[1].id]).dists
        - end
        - 
        - """
        -     sort_blocks!(ir::BBCode)::BBCode
        - 
        - Ensure that blocks appear in order of distance-from-entry-point, where distance the
        - distance from block b to the entry point is defined to be the minimum number of basic
        - blocks that must be passed through in order to reach b.
        - 
        - For reasons unknown (to me, Will), the compiler / optimiser needs this for inference to
        - succeed. Since we do quite a lot of re-ordering on the reverse-pass of AD, this is a problem
        - there.
        - 
        - WARNING: use with care. Only use if you are confident that arbitrary re-ordering of basic
        - blocks in `ir` is valid. Notably, this does not hold if you have any `IDGotoIfNot` nodes in
        - `ir`.
        - """
        3 function sort_blocks!(ir::BBCode)::BBCode
        3     I = sortperm(_distance_to_entry(ir.blocks))
        6     ir.blocks .= ir.blocks[I]
        3     return ir
        - end
        - 
        - """
        -     characterise_unique_predecessor_blocks(blks::Vector{BBlock}) ->
        -         Tuple{Dict{ID, Bool}, Dict{ID, Bool}}
        - 
        - We call a block `b` a _unique_ _predecessor_ in the control flow graph associated to `blks`
        - if it is the only predecessor to all of its successors. Put differently we call `b` a unique
        - predecessor if, whenever control flow arrives in any of the successors of `b`, we know for
        - certain that the previous block must have been `b`.
        - 
        - Returns two `Dict`s. A value in the first `Dict` is `true` if the block associated to its
        - key is a unique precessor, and is `false` if not. A value in the second `Dict` is `true` if 
        - it has a single predecessor, and that predecessor is a unique predecessor.
        - 
        - *Context*:
        - 
        - This information is important for optimising AD because knowing that `b` is a unique
        - predecessor means that
        - 1. on the forwards-pass, there is no need to push the ID of `b` to the block stack when
        -     passing through it, and
        - 2. on the reverse-pass, there is no need to pop the block stack when passing through one of
        -     the successors to `b`.
        - 
        - Utilising this reduces the overhead associated to doing AD. It is quite important when
        - working with cheap loops -- loops where the operations performed at each iteration
        - are inexpensive -- for which minimising memory pressure is critical to performance. It is
        - also important for single-block functions, because it can be used to entirely avoid using a
        - block stack at all.
        - """
        6 function characterise_unique_predecessor_blocks(
        -     blks::Vector{BBlock}
        - )::Tuple{Dict{ID,Bool},Dict{ID,Bool}}
        - 
        -     # Obtain the block IDs in order -- this ensures that we get the entry block first.
        6     blk_ids = ID[b.id for b in blks]
        6     preds = _compute_all_predecessors(blks)
        6     succs = _compute_all_successors(blks)
        - 
        -     # The bulk of blocks can be hanled by this general loop.
        6     is_unique_pred = Dict{ID,Bool}()
        6     for id in blk_ids
       74         ss = succs[id]
      148         is_unique_pred[id] = !isempty(ss) && all(s -> length(preds[s]) == 1, ss)
       74     end
        - 
        -     # If there is a single reachable return node, then that block is treated as a unique
        -     # pred, since control can only pass "out" of the function via this block. Conversely,
        -     # if there are multiple reachable return nodes, then execution can return to the calling
        -     # function via any of them, so they are not unique predecessors.
        -     # Note that the previous block sets is_unique_pred[id] to false for all nodes which
        -     # end with a reachable return node, so the value only needs changing if there is a
        -     # unique reachable return node.
        6     reachable_return_blocks = filter(blks) do blk
      134         is_reachable_return_node(terminator(blk))
        -     end
        6     if length(reachable_return_blocks) == 1
        6         is_unique_pred[only(reachable_return_blocks).id] = true
        -     end
        - 
        -     # pred_is_unique_pred is true if the unique predecessor to a block is a unique pred.
        6     pred_is_unique_pred = Dict{ID,Bool}()
        6     for id in blk_ids
       74         pred_is_unique_pred[id] = length(preds[id]) == 1 && is_unique_pred[only(preds[id])]
       74     end
        - 
        -     # If the entry block has no predecessors, then it can only be entered once, when the
        -     # function is first entered. In this case, we treat it as having a unique predecessor.
        6     entry_id = blk_ids[1]
        6     pred_is_unique_pred[entry_id] = isempty(preds[entry_id])
        - 
        6     return is_unique_pred, pred_is_unique_pred
        - end
        - 
        - """
        -     is_reachable_return_node(x::ReturnNode)
        - 
        - Determine whether `x` is a `ReturnNode`, and if it is, if it is also reachable. This is
        - purely a function of whether or not its `val` field is defined or not.
        - """
       28 is_reachable_return_node(x::ReturnNode) = isdefined(x, :val)
        - is_reachable_return_node(x) = false
        - 
        - """
        -     characterise_used_ids(stmts::Vector{IDInstPair})::Dict{ID, Bool}
        - 
        - For each line in `stmts`, determine whether it is referenced anywhere else in the code.
        - Returns a dictionary containing the results. An element is `false` if the corresponding
        - `ID` is unused, and `true` if is used.
        - """
        3 function characterise_used_ids(stmts::Vector{IDInstPair})::Dict{ID,Bool}
        3     ids = first.(stmts)
        3     insts = last.(stmts)
        - 
        -     # Initialise to false.
      332     is_used = Dict{ID,Bool}(zip(ids, fill(false, length(ids))))
        - 
        -     # Hunt through the instructions, flipping a value in is_used to true whenever an ID
        -     # is encountered which corresponds to an SSA.
        3     for inst in insts
      332         _find_id_uses!(is_used, inst.stmt)
      332     end
        3     return is_used
        - end
        - 
        - """
        -     _find_id_uses!(d::Dict{ID, Bool}, x)
        - 
        - Helper function used in [`characterise_used_ids`](@ref). For all uses of `ID`s in `x`, set
        - the corresponding value of `d` to `true`.
        - 
        - For example, if `x = ReturnNode(ID(5))`, then this function sets `d[ID(5)] = true`.
        - """
      294 function _find_id_uses!(d::Dict{ID,Bool}, x::Expr)
      294     for arg in x.args
      177         in(arg, keys(d)) && setindex!(d, true, arg)
      177     end
        - end
        7 function _find_id_uses!(d::Dict{ID,Bool}, x::IDGotoIfNot)
        7     return in(x.cond, keys(d)) && setindex!(d, true, x.cond)
        - end
       16 _find_id_uses!(::Dict{ID,Bool}, ::IDGotoNode) = nothing
        - function _find_id_uses!(d::Dict{ID,Bool}, x::PiNode)
        -     return in(x.val, keys(d)) && setindex!(d, true, x.val)
        - end
        3 function _find_id_uses!(d::Dict{ID,Bool}, x::IDPhiNode)
        3     v = x.values
        3     for n in eachindex(v)
        6         isassigned(v, n) && in(v[n], keys(d)) && setindex!(d, true, v[n])
        6     end
        - end
        7 function _find_id_uses!(d::Dict{ID,Bool}, x::ReturnNode)
        7     return isdefined(x, :val) && in(x.val, keys(d)) && setindex!(d, true, x.val)
        - end
        - _find_id_uses!(d::Dict{ID,Bool}, x::QuoteNode) = nothing
        5 _find_id_uses!(d::Dict{ID,Bool}, x) = nothing
        - 
        - """
        -     _is_reachable(blks::Vector{BBlock})::Vector{Bool}
        - 
        - Computes a `Vector` whose length is `length(blks)`. The `n`th element is `true` iff it is
        - possible for control flow to reach the `n`th block.
        - """
        9 _is_reachable(blks::Vector{BBlock})::Vector{Bool} = _distance_to_entry(blks) .< typemax(Int)
        - 
        - """
        -     remove_unreachable_blocks!(ir::BBCode)::BBCode
        - 
        - If a basic block in `ir` cannot possibly be reached during execution, then it can be safely
        - removed from `ir` without changing its functionality.
        - A block is unreachable if either:
        - 1. it has no predecessors _and_ it is not the first block, or
        - 2. all of its predecessors are themselves unreachable.
        - 
        - For example, consider the following IR:
        - ```jldoctest remove_unreachable_blocks
        - julia> ir = Mooncake.ircode(
        -            Any[Core.ReturnNode(nothing), Expr(:call, sin, 5), Core.ReturnNode(Core.SSAValue(2))],
        -            Any[Any, Any, Any],
        -        );
        - ```
        - There is no possible way to reach the second basic block (lines 2 and 3). Applying this
        - function will therefore remove it, yielding the following:
        - ```jldoctest remove_unreachable_blocks
        - julia> Mooncake.IRCode(Mooncake.remove_unreachable_blocks!(Mooncake.BBCode(ir)))
        - 1 1 ─     return nothing
        - ```
        - 
        - In the blocks which have not been removed, there may be references to blocks which have been
        - removed. For example, the `edge`s in a `PhiNode` may contain a reference to a removed block.
        - These references are removed in-place from these remaining blocks, so this function will (in
        - general) modify `ir`.
        - """
        9 remove_unreachable_blocks!(ir::BBCode) = BBCode(ir, _remove_unreachable_blocks!(ir.blocks))
        - 
        9 function _remove_unreachable_blocks!(blks::Vector{BBlock})
        - 
        -     # Figure out which blocks are reachable.
        9     is_reachable = _is_reachable(blks)
        - 
        -     # Collect all blocks which are reachable.
        9     remaining_blks = blks[is_reachable]
        - 
        -     # For each reachable block, remove any references to removed blocks. These can appear in
        -     # `PhiNode`s with edges that come from remove blocks.
       13     removed_block_ids = map(idx -> blks[idx].id, findall(!, is_reachable))
        9     for blk in remaining_blks, inst in blk.insts
     2141         stmt = inst.stmt
     2141         stmt isa IDPhiNode || continue
       12         for n in reverse(1:length(stmt.edges))
       12             if stmt.edges[n] in removed_block_ids
        0                 deleteat!(stmt.edges, n)
        0                 deleteat!(stmt.values, n)
        -             end
       18         end
     2141     end
        - 
        9     return remaining_blks
        - end
        - 
        - end
